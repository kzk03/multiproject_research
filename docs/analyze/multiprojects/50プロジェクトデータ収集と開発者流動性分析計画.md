# 50プロジェクトデータ収集と開発者流動性分析計画

## エグゼクティブサマリー

既存のデータ収集パイプライン（`build_dataset.py`）を使用して、50プロジェクトのデータを取得します。また、**開発者の継続性と流動性**を分析するための新規特徴量を追加します。

---

## 1. データ収集計画（50プロジェクト）

### 1.1 既存実装の確認

✅ **データ収集パイプラインは実装済み**
- スクリプト: `scripts/pipeline/build_dataset.py`
- 機能: Gerrit REST APIから複数プロジェクトのデータ取得
- 特徴量: 67次元（既存）

### 1.2 50プロジェクトリスト

**選定済みの50プロジェクト**（詳細は [OpenStack50プロジェクト選定基準.md](OpenStack50プロジェクト選定基準.md) 参照）

```python
PROJECTS_50 = [
    # Tier 1: Interop必須コア（25）
    "openstack/nova",
    "openstack/python-novaclient",
    "openstack/placement",
    "openstack/nova-specs",
    "openstack/neutron",
    "openstack/python-neutronclient",
    "openstack/neutron-lib",
    "openstack/neutron-specs",
    "openstack/cinder",
    "openstack/python-cinderclient",
    "openstack/os-brick",
    "openstack/cinder-specs",
    "openstack/swift",
    "openstack/python-swiftclient",
    "openstack/swift-specs",
    "openstack/keystone",
    "openstack/python-keystoneclient",
    "openstack/keystoneauth",
    "openstack/glance",
    "openstack/python-glanceclient",
    "openstack/glance_store",
    "openstack/glance-specs",
    "openstack/horizon",
    "openstack/django_openstack_auth",
    "openstack/horizon-specs",

    # Tier 2: 重要サービス（15）
    "openstack/heat",
    "openstack/python-heatclient",
    "openstack/heat-specs",
    "openstack/ironic",
    "openstack/python-ironicclient",
    "openstack/ironic-inspector",
    "openstack/octavia",
    "openstack/python-octaviaclient",
    "openstack/manila",
    "openstack/python-manilaclient",
    "openstack/barbican",
    "openstack/python-barbicanclient",
    "openstack/designate",
    "openstack/python-designateclient",
    "openstack/magnum",

    # Tier 3: インフラ・SDK（7）
    "openstack/openstacksdk",
    "openstack/python-openstackclient",
    "openstack/oslo.config",
    "openstack/oslo.messaging",
    "openstack/oslo.db",
    "openstack/requirements",
    "openstack/releases",

    # Tier 4: デプロイメント（3）
    "openstack/kolla",
    "openstack/kolla-ansible",
    "openstack/devstack",
]
```

### 1.3 データ収集コマンド

```bash
# 50プロジェクトのデータ取得（2010-2024、14年間）
uv run python scripts/pipeline/build_dataset.py \
    --gerrit-url https://review.opendev.org \
    --project openstack/nova openstack/python-novaclient openstack/placement ... \
    --start-date 2010-01-01 \
    --end-date 2024-12-31 \
    --output data/openstack_50proj_2010_2024_raw.csv \
    --verbose
```

**推定データ量**:
- **レビュー数**: 600,000-1,000,000件
- **ファイルサイズ**: 300-500 MB（CSV）
- **収集時間**: 20-40時間（API制限考慮）

### 1.4 依存関係の扱い

**既存データセットの状況**:
```
現在の20プロジェクト: openstack_20proj_2020_2024_feat.csv
- プロジェクト間の依存関係情報は含まれていない
- is_cross_project: レビュアーが複数プロジェクトに参加しているかのフラグ
- reviewer_project_count: レビュアーが参加するプロジェクト数
```

**50プロジェクトでの依存関係**:

#### パターン1: 依存関係がある（階層構造）
```
例: nova → oslo.messaging, oslo.config, oslo.db
    neutron → neutron-lib
    glance → glance_store
```

#### パターン2: 依存関係がない（並列関係）
```
例: nova ←→ neutron（独立したサービス）
    cinder ←→ swift（独立したサービス）
```

**依存関係の取得方法**:

**方法1**: `requirements.txt`から自動抽出
```python
# 各プロジェクトのrequirements.txtを取得
GET /projects/{project}/branches/master/files/requirements.txt/content

# oslo.*, python-*clientの依存を抽出
# 例: requirements.txtに "oslo.messaging>=5.0.0" → oslo.messagingに依存
```

**方法2**: `setup.cfg`のinstall_requiresから抽出
```python
# setup.cfgを取得
GET /projects/{project}/branches/master/files/setup.cfg/content

# [options]セクションのinstall_requiresを解析
```

**方法3**: 手動定義（推奨）
```python
# 主要な依存関係を手動で定義（最も確実）
PROJECT_DEPENDENCIES = {
    "openstack/nova": [
        "openstack/oslo.config",
        "openstack/oslo.messaging",
        "openstack/oslo.db",
        "openstack/python-novaclient",
        "openstack/placement",
    ],
    "openstack/neutron": [
        "openstack/neutron-lib",
        "openstack/oslo.config",
        "openstack/oslo.messaging",
        "openstack/python-neutronclient",
    ],
    # ... 他のプロジェクトも同様
}
```

---

## 2. 開発者の継続性と流動性の分析

### 2.1 分析の目的

**リサーチクエスチョン**:
1. 開発者はプロジェクト間でどのように移動するか？
2. 長期的に同じプロジェクトに留まる開発者の特徴は？
3. プロジェクト間を流動する開発者のレビュー承諾率は？
4. プロジェクト依存関係が開発者の流動性に与える影響は？

### 2.2 新規特徴量の定義

#### カテゴリA: 開発者の継続性（Developer Retention）

| 特徴量名 | 定義 | 計算方法 |
|---------|------|---------|
| `developer_tenure_in_project_days` | プロジェクトでの在籍日数 | 最初のレビュー日から現在までの日数 |
| `developer_activity_continuity_180d` | 過去180日の活動継続率 | 活動した月数 / 6ヶ月 |
| `developer_consecutive_active_months` | 連続活動月数 | 最長の連続活動期間（月単位） |
| `developer_review_frequency_trend` | レビュー頻度のトレンド | 過去90日と過去180日の比較 |
| `developer_is_core_reviewer` | コアレビュアーフラグ | 過去180日で50件以上レビュー |

#### カテゴリB: 開発者の流動性（Developer Mobility）

| 特徴量名 | 定義 | 計算方法 |
|---------|------|---------|
| `developer_projects_participated_180d` | 過去180日の参加プロジェクト数 | ユニークプロジェクト数 |
| `developer_projects_participated_all` | 全期間の参加プロジェクト数 | ユニークプロジェクト数（全履歴） |
| `developer_project_switch_rate_180d` | プロジェクト切替率 | プロジェクト切替回数 / 総レビュー数 |
| `developer_primary_project_ratio` | 主要プロジェクト集中度 | メインプロジェクトのレビュー数 / 総レビュー数 |
| `developer_cross_project_experience` | クロスプロジェクト経験値 | 異なるプロジェクトでのレビュー数の合計 |

#### カテゴリC: プロジェクト間の移動パターン

| 特徴量名 | 定義 | 計算方法 |
|---------|------|---------|
| `developer_moved_from_dependent_project` | 依存プロジェクトからの移動 | 直前のプロジェクトが依存関係にあるか |
| `developer_moved_to_related_project` | 関連プロジェクトへの移動 | 現プロジェクトが関連性があるか |
| `developer_project_cluster_id` | プロジェクトクラスタID | Core/Deployment/Infra等のカテゴリ |
| `developer_stayed_in_cluster` | 同一クラスタ内滞在 | 過去のプロジェクトと同じクラスタか |

#### カテゴリD: チーム・コミュニティの安定性

| 特徴量名 | 定義 | 計算方法 |
|---------|------|---------|
| `project_reviewer_turnover_rate_180d` | レビュアー離脱率 | 180日前のレビュアーで消えた割合 |
| `project_new_reviewer_rate_180d` | 新規レビュアー率 | 過去180日の新規レビュアー割合 |
| `project_core_reviewer_stability` | コアレビュアー安定性 | コアレビュアーの残存率 |
| `developer_worked_with_stable_team` | 安定チームとの協働 | 協働レビュアーの平均在籍期間 |

### 2.3 計算アルゴリズム

#### アルゴリズム1: 開発者の継続性スコア

```python
def calculate_developer_continuity(developer_email, project, context_date, history_df):
    """
    開発者の継続性スコアを計算

    Args:
        developer_email: 開発者のメールアドレス
        project: プロジェクト名
        context_date: 基準日
        history_df: 過去のレビュー履歴

    Returns:
        dict: 継続性関連の特徴量
    """
    # プロジェクトでの全履歴を取得
    dev_history = history_df[
        (history_df['reviewer_email'] == developer_email) &
        (history_df['project'] == project) &
        (history_df['request_time'] < context_date)
    ].sort_values('request_time')

    if len(dev_history) == 0:
        return {
            'developer_tenure_in_project_days': 0,
            'developer_activity_continuity_180d': 0.0,
            'developer_consecutive_active_months': 0,
        }

    # 在籍日数
    first_review = dev_history['request_time'].min()
    tenure_days = (context_date - first_review).days

    # 過去180日の活動継続率
    recent_history = dev_history[
        dev_history['request_time'] >= context_date - timedelta(days=180)
    ]
    active_months = recent_history['request_time'].dt.to_period('M').nunique()
    continuity = active_months / 6.0  # 6ヶ月中何ヶ月活動したか

    # 連続活動月数
    monthly_counts = dev_history.groupby(
        dev_history['request_time'].dt.to_period('M')
    ).size()
    consecutive_months = calculate_max_consecutive_months(monthly_counts)

    return {
        'developer_tenure_in_project_days': tenure_days,
        'developer_activity_continuity_180d': continuity,
        'developer_consecutive_active_months': consecutive_months,
    }
```

#### アルゴリズム2: 開発者の流動性スコア

```python
def calculate_developer_mobility(developer_email, context_date, history_df):
    """
    開発者の流動性スコアを計算

    Returns:
        dict: 流動性関連の特徴量
    """
    # 過去180日の履歴
    recent_history = history_df[
        (history_df['reviewer_email'] == developer_email) &
        (history_df['request_time'] >= context_date - timedelta(days=180)) &
        (history_df['request_time'] < context_date)
    ]

    # 全履歴
    all_history = history_df[
        (history_df['reviewer_email'] == developer_email) &
        (history_df['request_time'] < context_date)
    ]

    # 参加プロジェクト数
    projects_180d = recent_history['project'].nunique()
    projects_all = all_history['project'].nunique()

    # プロジェクト切替率（プロジェクトが変わった回数 / 総レビュー数）
    sorted_history = recent_history.sort_values('request_time')
    project_switches = (sorted_history['project'] != sorted_history['project'].shift()).sum() - 1
    switch_rate = project_switches / len(sorted_history) if len(sorted_history) > 0 else 0.0

    # 主要プロジェクト集中度
    if len(recent_history) > 0:
        primary_project = recent_history['project'].value_counts().iloc[0]
        primary_count = recent_history['project'].value_counts().iloc[0]
        primary_ratio = primary_count / len(recent_history)
    else:
        primary_ratio = 0.0

    return {
        'developer_projects_participated_180d': projects_180d,
        'developer_projects_participated_all': projects_all,
        'developer_project_switch_rate_180d': switch_rate,
        'developer_primary_project_ratio': primary_ratio,
    }
```

#### アルゴリズム3: プロジェクト間移動パターン

```python
def calculate_project_transition_features(
    developer_email,
    current_project,
    context_date,
    history_df,
    project_dependencies
):
    """
    プロジェクト間の移動パターンを分析

    Args:
        project_dependencies: プロジェクト依存関係の辞書
            例: {"openstack/nova": ["openstack/oslo.config", ...]}
    """
    # 直前のレビューのプロジェクトを取得
    recent_reviews = history_df[
        (history_df['reviewer_email'] == developer_email) &
        (history_df['request_time'] < context_date)
    ].sort_values('request_time', ascending=False)

    if len(recent_reviews) == 0:
        return {
            'developer_moved_from_dependent_project': False,
            'developer_stayed_in_cluster': True,
        }

    previous_project = recent_reviews.iloc[0]['project']

    # 依存プロジェクトからの移動か？
    moved_from_dependent = previous_project in project_dependencies.get(current_project, [])

    # 同一クラスタ内か？
    current_cluster = get_project_cluster(current_project)
    previous_cluster = get_project_cluster(previous_project)
    stayed_in_cluster = (current_cluster == previous_cluster)

    return {
        'developer_moved_from_dependent_project': moved_from_dependent,
        'developer_stayed_in_cluster': stayed_in_cluster,
    }


def get_project_cluster(project):
    """プロジェクトのクラスタを返す"""
    clusters = {
        'Core': ['openstack/nova', 'openstack/neutron', 'openstack/cinder', ...],
        'Storage': ['openstack/swift', 'openstack/manila', 'openstack/glance', ...],
        'Infra': ['openstack/oslo.config', 'openstack/oslo.messaging', ...],
        'Deployment': ['openstack/kolla', 'openstack/devstack', ...],
    }
    for cluster_name, projects in clusters.items():
        if project in projects:
            return cluster_name
    return 'Other'
```

---

## 3. 実装計画

### 3.1 Phase 1: 50プロジェクトデータ収集（Week 1-2）

#### Week 1: データ収集スクリプト準備

**タスク1-1**: プロジェクトリストファイル作成
```bash
# projects_50.txt
openstack/nova
openstack/python-novaclient
openstack/placement
...
```

**タスク1-2**: データ収集の実行（バックグラウンド）
```bash
# tmux/screenで実行して放置
nohup uv run python scripts/pipeline/build_dataset.py \
    --gerrit-url https://review.opendev.org \
    --projects-file projects_50.txt \
    --start-date 2010-01-01 \
    --end-date 2024-12-31 \
    --output data/openstack_50proj_2010_2024_raw.csv \
    --checkpoint-file data/checkpoint_50proj.json \
    --verbose > logs/data_collection_50proj.log 2>&1 &
```

**推定時間**: 20-40時間（並列化により短縮可能）

#### Week 2: データ検証・前処理

**タスク2-1**: データ品質確認
```python
# データ検証スクリプト
df = pd.read_csv('data/openstack_50proj_2010_2024_raw.csv')
print(f"総レビュー数: {len(df)}")
print(f"プロジェクト数: {df['project'].nunique()}")
print(f"レビュアー数: {df['reviewer_email'].nunique()}")
print(f"期間: {df['request_time'].min()} - {df['request_time'].max()}")
print(f"欠損値:\n{df.isnull().sum()}")
```

**タスク2-2**: 基本統計の確認
- プロジェクト別レビュー数
- 年次トレンド
- レビュアー分布

### 3.2 Phase 2: 開発者流動性特徴量の実装（Week 3-4）

#### Week 3: 新規特徴量エンジニアリング

**タスク3-1**: 依存関係マッピングの作成
```python
# scripts/pipeline/project_dependencies.py
PROJECT_DEPENDENCIES = {
    "openstack/nova": [
        "openstack/oslo.config",
        "openstack/oslo.messaging",
        "openstack/oslo.db",
        "openstack/python-novaclient",
        "openstack/placement",
    ],
    # ... 50プロジェクトすべての依存関係を定義
}

PROJECT_CLUSTERS = {
    "openstack/nova": "Core",
    "openstack/neutron": "Core",
    "openstack/cinder": "Core",
    "openstack/swift": "Storage",
    "openstack/oslo.config": "Infra",
    # ... 50プロジェクトすべてのクラスタを定義
}
```

**タスク3-2**: 継続性・流動性特徴量の実装
```python
# scripts/pipeline/add_developer_mobility_features.py
"""
開発者の継続性と流動性の特徴量を追加するスクリプト

入力: openstack_50proj_2010_2024_raw.csv（既存67特徴量）
出力: openstack_50proj_2010_2024_feat.csv（67+20=87特徴量）

新規追加特徴量（20次元）:
- 継続性: 5次元
- 流動性: 5次元
- プロジェクト移動: 4次元
- チーム安定性: 4次元
- 依存関係: 2次元
"""

def add_mobility_features(input_csv, output_csv):
    df = pd.read_csv(input_csv)
    df['request_time'] = pd.to_datetime(df['request_time'])

    # 新規特徴量を格納するリスト
    mobility_features = []

    for idx, row in tqdm(df.iterrows(), total=len(df)):
        # 過去の履歴を取得（データリーク防止）
        history = df[df['request_time'] < row['request_time']]

        # 継続性特徴量
        continuity = calculate_developer_continuity(
            row['reviewer_email'],
            row['project'],
            row['request_time'],
            history
        )

        # 流動性特徴量
        mobility = calculate_developer_mobility(
            row['reviewer_email'],
            row['request_time'],
            history
        )

        # プロジェクト移動特徴量
        transition = calculate_project_transition_features(
            row['reviewer_email'],
            row['project'],
            row['request_time'],
            history,
            PROJECT_DEPENDENCIES
        )

        # 統合
        features = {**continuity, **mobility, **transition}
        mobility_features.append(features)

    # データフレームに追加
    mobility_df = pd.DataFrame(mobility_features)
    result = pd.concat([df, mobility_df], axis=1)
    result.to_csv(output_csv, index=False)
    print(f"特徴量次元数: {len(result.columns)}次元")
```

#### Week 4: 特徴量の検証と可視化

**タスク4-1**: 特徴量分布の確認
```python
# 継続性スコアの分布
plt.hist(df['developer_activity_continuity_180d'], bins=50)
plt.title('Developer Activity Continuity Distribution')

# 流動性スコアの分布
plt.hist(df['developer_projects_participated_180d'], bins=20)
plt.title('Developer Mobility Distribution')
```

**タスク4-2**: 相関分析
```python
# 継続性・流動性とレビュー承諾率の相関
correlation_matrix = df[[
    'label',
    'developer_tenure_in_project_days',
    'developer_activity_continuity_180d',
    'developer_projects_participated_180d',
    'developer_primary_project_ratio',
]].corr()

sns.heatmap(correlation_matrix, annot=True)
```

### 3.3 Phase 3: 分析とレポート作成（Week 5）

#### Week 5: 開発者流動性の包括的分析

**タスク5-1**: 流動性パターンの分類
```python
# 開発者を4つのタイプに分類
def classify_developer_type(row):
    """
    Type 1: Specialists（専門家）
        - 1つのプロジェクトに集中（primary_ratio > 0.8）
        - 長期在籍（tenure > 365日）

    Type 2: Core Contributors（コア貢献者）
        - 複数プロジェクト参加（2-4プロジェクト）
        - 高い継続性（continuity > 0.7）

    Type 3: Explorers（探索者）
        - 多数のプロジェクト参加（5+プロジェクト）
        - 短期滞在（switch_rate > 0.3）

    Type 4: Newcomers（新規参加者）
        - 短い在籍期間（tenure < 180日）
    """
    if row['developer_tenure_in_project_days'] < 180:
        return 'Newcomer'
    elif row['developer_primary_project_ratio'] > 0.8:
        return 'Specialist'
    elif row['developer_projects_participated_180d'] >= 5:
        return 'Explorer'
    else:
        return 'Core Contributor'

df['developer_type'] = df.apply(classify_developer_type, axis=1)
```

**タスク5-2**: タイプ別レビュー承諾率の分析
```python
# タイプ別の統計
type_stats = df.groupby('developer_type').agg({
    'label': 'mean',  # 承諾率
    'reviewer_email': 'nunique',  # レビュアー数
    'change_id': 'count',  # レビュー数
}).rename(columns={'label': 'acceptance_rate'})

print(type_stats)
```

**タスク5-3**: プロジェクト間移動の可視化
```python
# Sankey diagram: プロジェクト間の開発者移動
import plotly.graph_objects as go

# 開発者の移動パターンを抽出
transitions = []
for dev in df['reviewer_email'].unique():
    dev_history = df[df['reviewer_email'] == dev].sort_values('request_time')
    projects = dev_history['project'].values
    for i in range(len(projects) - 1):
        transitions.append((projects[i], projects[i+1]))

# Sankey図作成
fig = go.Figure(data=[go.Sankey(...)])
fig.write_html('docs/figures/developer_mobility/project_transitions.html')
```

**タスク5-4**: 依存関係と移動パターンの分析
```python
# 依存プロジェクト間の移動割合
dependent_moves = df[df['developer_moved_from_dependent_project'] == True]
print(f"依存プロジェクトからの移動: {len(dependent_moves) / len(df) * 100:.1f}%")

# 同一クラスタ内滞在率
same_cluster = df[df['developer_stayed_in_cluster'] == True]
print(f"同一クラスタ滞在: {len(same_cluster) / len(df) * 100:.1f}%")
```

---

## 4. 期待される分析結果

### 4.1 仮説

**仮説1**: **Specialists（専門家）は高い承諾率を示す**
- 理由: 長期在籍により、プロジェクトの文化・コードベースを深く理解

**仮説2**: **Core Contributors（コア貢献者）は中程度の承諾率**
- 理由: 複数プロジェクトの知識を持つが、各プロジェクトの専門性は限定的

**仮説3**: **Explorers（探索者）は低い承諾率**
- 理由: プロジェクト間を頻繁に移動し、各プロジェクトへのコミットが浅い

**仮説4**: **依存プロジェクトからの移動は承諾率を向上させる**
- 理由: oslo.* → novaのように、依存関係の知識が活かせる

**仮説5**: **チームが安定しているプロジェクトでは承諾率が高い**
- 理由: 低い離脱率により、レビュアー間の信頼関係が構築されている

### 4.2 予測される発見

#### 発見1: プロジェクトクラスタ別の特性

| クラスタ | 主な特徴 | 承諾率（予測） |
|---------|---------|--------------|
| **Core** | 多数の専門家、低い流動性 | 65-75% |
| **Storage** | 中程度の流動性 | 60-70% |
| **Infra（Oslo）** | 高い流動性（多くのプロジェクトから参照） | 55-65% |
| **Deployment** | 新規参加者が多い | 50-60% |

#### 発見2: 時系列トレンド

```
2010-2015: 高い流動性（OpenStack黎明期、探索的な参加）
2016-2020: 流動性低下（専門化が進む）
2021-2024: 再び流動性上昇（コンテナ化・マイクロサービス化）
```

#### 発見3: 依存関係の影響

```
依存プロジェクトからの移動: 承諾率 +5-10%
関連性のないプロジェクトへの移動: 承諾率 -5-10%
```

---

## 5. データ構造とファイル構成

### 5.1 最終的なデータセット

**ファイル名**: `data/openstack_50proj_2010_2024_feat.csv`

**特徴量次元数**: **87次元**
- 既存特徴量: 67次元
- 新規特徴量: 20次元

**新規特徴量の内訳**:
```
継続性（5次元）:
  - developer_tenure_in_project_days
  - developer_activity_continuity_180d
  - developer_consecutive_active_months
  - developer_review_frequency_trend
  - developer_is_core_reviewer

流動性（5次元）:
  - developer_projects_participated_180d
  - developer_projects_participated_all
  - developer_project_switch_rate_180d
  - developer_primary_project_ratio
  - developer_cross_project_experience

プロジェクト移動（4次元）:
  - developer_moved_from_dependent_project
  - developer_moved_to_related_project
  - developer_project_cluster_id
  - developer_stayed_in_cluster

チーム安定性（4次元）:
  - project_reviewer_turnover_rate_180d
  - project_new_reviewer_rate_180d
  - project_core_reviewer_stability
  - developer_worked_with_stable_team

依存関係（2次元）:
  - project_has_dependencies (boolean)
  - project_dependency_count (integer)
```

### 5.2 補助ファイル

```
data/
  ├── openstack_50proj_2010_2024_raw.csv        # 生データ（67次元）
  ├── openstack_50proj_2010_2024_feat.csv       # 特徴量追加後（87次元）
  ├── project_dependencies.json                 # 依存関係マッピング
  ├── project_clusters.json                     # クラスタ分類
  └── developer_types_stats.csv                 # 開発者タイプ別統計

docs/figures/developer_mobility/
  ├── developer_type_distribution.png           # タイプ別分布
  ├── acceptance_rate_by_type.png               # タイプ別承諾率
  ├── project_transitions.html                  # プロジェクト間移動（Sankey）
  ├── continuity_vs_acceptance.png              # 継続性と承諾率の関係
  ├── mobility_vs_acceptance.png                # 流動性と承諾率の関係
  └── cluster_mobility_matrix.png               # クラスタ間移動マトリクス
```

---

## 6. 実装スケジュール

| Phase | Week | タスク | 成果物 |
|-------|------|--------|--------|
| **Phase 1** | Week 1 | データ収集準備・実行 | 収集スクリプト実行中 |
|  | Week 2 | データ検証・前処理 | `openstack_50proj_2010_2024_raw.csv` |
| **Phase 2** | Week 3 | 流動性特徴量実装 | `add_developer_mobility_features.py` |
|  | Week 4 | 特徴量検証・可視化 | `openstack_50proj_2010_2024_feat.csv` |
| **Phase 3** | Week 5 | 包括的分析・レポート | 分析レポート、可視化6-8図 |

**合計**: **5週間**

---

## 7. まとめ

### データ収集

✅ **既存実装を活用**: `build_dataset.py`で50プロジェクトを一括取得
- コマンド1つで実行可能
- 推定20-40時間で完了

### 依存関係の扱い

**3つのアプローチ**:
1. ✅ **手動定義（推奨）**: 主要50プロジェクトの依存関係を明示的に定義
2. `requirements.txt`解析: 自動化可能だが精度に課題
3. `setup.cfg`解析: より詳細だが複雑

### 開発者流動性分析

**新規20次元の特徴量**:
- 継続性: 5次元
- 流動性: 5次元
- プロジェクト移動: 4次元
- チーム安定性: 4次元
- 依存関係: 2次元

**期待される発見**:
- Specialistsは高承諾率（65-75%）
- 依存プロジェクトからの移動は+5-10%の承諾率向上
- Coreクラスタは最も安定（低い流動性、高い承諾率）

### 次のアクション

1. **Week 1**: 50プロジェクトのデータ収集開始
2. **Week 2**: データ検証・品質確認
3. **Week 3**: 依存関係マッピング作成 + 流動性特徴量実装
4. **Week 4**: 特徴量検証・可視化
5. **Week 5**: 包括的分析レポート作成

